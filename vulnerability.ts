/**
 * Vulnerability checking logic
 */

import fs from 'node:fs';
import path from 'node:path';
import { fileURLToPath } from 'node:url';
import { satisfies, valid } from 'semver';
import { z } from 'zod';
import * as z4 from 'zod/v4/core';

import type { Platform, VulnerabilityEntry } from './types.js';

import { isNodeEOL } from './schedule.js';
import { securityDatabaseSchema } from './schemas.js';
import { PLATFORMS } from './types.js';

// Find project root by looking for package.json
function findProjectRoot(startPath: string): string {
	let currentPath = startPath;
	while (currentPath !== path.dirname(currentPath)) {
		if (fs.existsSync(path.join(currentPath, 'package.json'))) {
			return currentPath;
		}
		currentPath = path.dirname(currentPath);
	}
	throw new Error('Could not find project root (package.json not found)');
}

const __dirname = path.dirname(fileURLToPath(import.meta.url));
const PROJECT_ROOT = findProjectRoot(__dirname);
const SECURITY_FILE = path.join(PROJECT_ROOT, 'data/security.json');

type SecurityDatabase = z4.output<typeof securityDatabaseSchema>;

/**
 * Validate that a platform string is a valid Platform type
 *
 * @param platform - Platform string to validate
 * @throws Error if platform is not valid
 */
export function checkPlatform(
	platform?: string,
): asserts platform is Platform | undefined {
	if (platform !== undefined && !PLATFORMS.includes(platform as Platform)) {
		throw new Error(
			`Platform '${platform}' is not valid. Use: ${PLATFORMS.join(', ')}`,
		);
	}
}

export function getVulnerabilityList(
	currentVersion: string,
	platform?: Platform,
	securityDb?: SecurityDatabase,
): VulnerabilityEntry[] {
	const vulnerabilities: VulnerabilityEntry[] = [];

	for (const vuln of Object.values(securityDb ?? {})) {
		const isVulnerable =
			satisfies(currentVersion, vuln.vulnerable) &&
			!satisfies(currentVersion, vuln.patched);

		const isPlatformAffected = isSystemAffected(
			vuln.affectedEnvironments,
			platform,
		);

		if (isVulnerable && isPlatformAffected) {
			vulnerabilities.push(vuln);
		}
	}

	return vulnerabilities;
}

/**
 * Check if a Node.js version is vulnerable to known CVEs
 *
 * @param version - Node.js version (e.g., "v20.10.0", "18.0.0")
 * @param platform - Optional platform (darwin, linux, win32, etc.)
 * @returns True if vulnerable or end-of-life, false otherwise
 * @throws Error if version or platform is invalid
 *
 * @example
 * ```typescript
 * const vulnerable = isNodeVulnerable('v20.10.0', 'darwin');
 * console.log(vulnerable); // false
 * ```
 */
export function isNodeVulnerable(
	platform?: Platform,
	version?: string,
): boolean {
	validateVersion(version ?? '');
	checkPlatform(platform);

	const isEOL = isNodeEOL(version ?? '');
	if (isEOL) {
		return true;
	}

	const data = fs.readFileSync(SECURITY_FILE, 'utf-8');
	const securityDb = z.parse(securityDatabaseSchema, JSON.parse(data));

	const vulnerabilities = getVulnerabilityList(
		version ?? '',
		platform,
		securityDb,
	);

	return vulnerabilities.length > 0;
}

function isSystemAffected(
	affectedEnvironments?: string[],
	platform?: Platform,
): boolean {
	if (platform === undefined || !Array.isArray(affectedEnvironments)) {
		return true;
	}

	return (
		affectedEnvironments.includes(platform) ||
		affectedEnvironments.includes('all')
	);
}

/**
 * Validate a semver version string
 *
 * @param version - Version string to validate
 * @throws Error if version is invalid
 */
function validateVersion(version: string): void {
	if (valid(version) === null) {
		throw new Error(`Invalid semver version: ${version}`);
	}
}
